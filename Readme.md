# big_integer

## Условие задания

В данном задании необходимо написать класс длинное знаковое число. Требования к решению следующие:

1. Реализация должна содержаться в классе `big_integer` и находиться в файле `big_integer.h`. Класс должен содержать:
   * Конструктор по умолчанию, инициализирующий число нулем.
   * Конструктор копирования, после которого исходный объект и копию можно изменять независимо.
   * Конструктор от `int`.
   * Explicit конструктор от `std::string`.
   * Оператор присваивания.
   * Операторы сравнения.
   * Арифметические операции: сложение, вычитание, изменение знака (унарный минус), унарный плюс.
   * Умножение работающее за время `O(nm)`, где `n,m` — длины множителей в битах.
   * Деление и остаток от деления работающие за время `O(nm)`, где `n` — длина делителя в битах, а `m` — длина частного в битах.
   * Префиксный/постфиксный инкремент/декремент. (опционально)
   * Битовые операции: и, или, исключающее или, не.
   * Битовые сдвиги.

2. Должна существовать глобальная функция `std::string to_string(big_integer const&)` возвращающая строковое представление числа.
3. Реализация функций класса должна быть расположена в файле `big_integer.cpp`.
4. Пользоваться сторонними библиотеками длинных чисел при выполнении этого задания нельзя.
5. Разряды числа должны представляться 32-битными либо 64-битными числами. При этом необходимо, чтобы все биты в их представлении использовались. Например, нельзя хранить разряды как 64-битные числа, но использовать только младшие 32-бита в них.
6. Реализация должна использовать арифметические операции той битности, которая естественна для данного представления разрядов. Например, нельзя разбивать разряды на отдельные биты, и делать операции в системе счисления с основанием 2.

## Полезная информация

1. По [ссылке](https://github.com/sorokin/cpp-course/tree/master/bigint) можно найти:
   * [big_integer_testing.cpp](https://github.com/sorokin/cpp-course/blob/master/bigint/big_integer_testing.cpp) — набор модульных тестов для проверки корректности вашей программы. Прохождение этого набора тестов является необходимым, но не достаточным условием сдачи данного задания. При необходимости, этот набор тестов будет расширяться и дополняться. Тесты реализованы с помощью библиотеки gtest (Google Test).
   * [gtest/](https://github.com/sorokin/cpp-course/tree/master/bigint/gtest) — библиотека [gtest](https://code.google.com/p/googletest/).
   * [big_integer.](https://github.com/sorokin/cpp-course/blob/master/bigint/big_integer.h){[h](https://github.com/sorokin/cpp-course/blob/master/bigint/big_integer.h), [cpp](https://github.com/sorokin/cpp-course/blob/master/bigint/big_integer.cpp)} — реализация класса длинного числа с использованием библиотеки [GNU Multi-Precision](https://gmplib.org/), которая проходит приведенные тесты.
2. Перед тем как писать код, возможно, стоит ознакомиться с книгой [Richard Brent, Paul Zimmermann — Modern Computer Arithmetic](http://www.loria.fr/~zimmerma/mca/mca-0.5.pdf). Про деление есть замечательная статья [Multiple-Length Division Revisited: A Tour of the Minefield](http://surface.syr.edu/cgi/viewcontent.cgi?article=1162&context=eecs_techreports).

# Small Object & Copy-on-Write optimisation

## Условие задания

В данном задании необходимо реализовать класс длинного числа со small-object и copy-on-write оптимизациями.

1. Длинное число должно удовлетворять всем требованиям задания `big_integer`.
2. Дополнительные требования:
   * Если в `big_integer` хранится число `-2N ≤ a ≤ 2N-1`, `big_integer` не должен выделять динамическую память. Конкретное значение `N` вы можете выбрать самостоятельно, допустимыми являются любые `N ≥ 30`.
   * Числа `a < -2N` и `a > 2N-1` должны выделять не больше одного блока динамической памяти на каждый экземпляр `big_integer`.
   * Конструктор копирования и оператор присваивания должны работать за `O(1)` и удовлетворять гарантии безопасности исключений nothrow.